["have n_pos : 0 < n := by linarith", "have : 1 \u2264 n := by linarith", "have h1 : 1 \u2264 1 := by linarith", "have : 1 \u2264 2 := by linarith", "norm_num"]
"n : \u2115\nh : 2 \u2264 n\nn_pos : 0 < n\nthis\u271d : 1 \u2264 n\nh1 : 1 \u2264 1\nthis : 1 \u2264 2\n\u22a2 \u2211 k in Ico 1 (n + 1), k ^ 2 * Nat.choose n k = n * ((n - 1) * 2 ^ (n - 2) + 2 ^ (n - 1))"

["rw [cast_sum (range (n+1)) fun x => x * Nat.choose (2 * n) x]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1), \u2191n * \u2191(Nat.choose (2 * n) k) - \u2211 x in range (n + 1), \u2191(x * Nat.choose (2 * n) x) =\n    \u2191(\u2211 k in range (n + 1), n * Nat.choose (2 * n) k) - \u2211 x in range (n + 1), \u2191(x * Nat.choose (2 * n) x)"

["rw [cast_sum, cast_sum]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1), \u2191n * \u2191(Nat.choose (2 * n) k) - \u2211 x in range (n + 1), \u2191(x * Nat.choose (2 * n) x) =\n    \u2211 x in range (n + 1), \u2191(n * Nat.choose (2 * n) x) - \u2211 x in range (n + 1), \u2191(x * Nat.choose (2 * n) x)"

["congr 1"]
"case e_a\nn : \u2115\n\u22a2 \u2211 k in range (n + 1), \u2191n * \u2191(Nat.choose (2 * n) k) = \u2191(\u2211 k in range (n + 1), n * Nat.choose (2 * n) k)"

["rw[Finset.sum_range_add_sum_Ico]"]
"n : \u2115\n\u22a2 2 ^ (2 * n) = \u2211 k in range (2 * n + 1), Nat.choose (2 * n) k\n\ncase h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["rw [Finset.sum_range_add]"]
"n : \u2115\n\u22a2 2 ^ (2 * n) =\n    \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) +\n      \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]"]
"n : \u2115\n\u22a2 (2 ^ 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "rw [Finset.sum_range_add_sum_Ico]"]
"n : \u2115\n\u22a2 (2 ^ 2) ^ n = \u2211 k in range (2 * n + 1), Nat.choose (2 * n) k\n\ncase h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]"]
"n : \u2115\n\u22a2 (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "simp only [Nat.pow_succ, Nat.pow_one]"]
"n : \u2115\n\u22a2 (2 ^ 0 * 2 * 2) ^ n =\n    \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "rw [Finset.sum_range_add]"]
"n : \u2115\n\u22a2 (2 ^ 2) ^ n =\n    \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) +\n      \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "rw[Nat.pow_succ]"]
"n : \u2115\n\u22a2 (2 ^ 1 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "induction' n with n ih"]
"case zero\n\u22a2 (2 ^ 2) ^ zero =\n    \u2211 k in range (zero + 1), Nat.choose (2 * zero) k + \u2211 k in Ico (zero + 1) (2 * zero + 1), Nat.choose (2 * zero) k\n\ncase succ\nn : \u2115\nih : (2 ^ 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 ^ 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "rw [sum_range_add_sum_Ico]"]
"n : \u2115\n\u22a2 (2 * 2) ^ n = \u2211 k in range (2 * n + 1), Nat.choose (2 * n) k\n\ncase h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["rw[Nat.pow_mul]", "induction' n with n ih", "simp"]
"case succ\nn : \u2115\nih : (2 ^ 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 ^ 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "rw [Finset.sum_range_add]"]
"n : \u2115\n\u22a2 (2 * 2) ^ n =\n    \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) +\n      \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "simp only [mul_pow]"]
"n : \u2115\n\u22a2 2 ^ n * 2 ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n hn"]
"case zero\n\u22a2 (2 * 2) ^ zero =\n    \u2211 k in range (zero + 1), Nat.choose (2 * zero) k + \u2211 k in Ico (zero + 1) (2 * zero + 1), Nat.choose (2 * zero) k\n\ncase succ\nn : \u2115\nhn : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n ih"]
"case zero\n\u22a2 (2 * 2) ^ zero =\n    \u2211 k in range (zero + 1), Nat.choose (2 * zero) k + \u2211 k in Ico (zero + 1) (2 * zero + 1), Nat.choose (2 * zero) k\n\ncase succ\nn : \u2115\nih : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n IH"]
"case zero\n\u22a2 (2 * 2) ^ zero =\n    \u2211 k in range (zero + 1), Nat.choose (2 * zero) k + \u2211 k in Ico (zero + 1) (2 * zero + 1), Nat.choose (2 * zero) k\n\ncase succ\nn : \u2115\nIH : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "simp only [mul_pow]", "rw [Finset.sum_range_add_sum_Ico]"]
"n : \u2115\n\u22a2 2 ^ n * 2 ^ n = \u2211 k in range (2 * n + 1), Nat.choose (2 * n) k\n\ncase h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n hn", "simp"]
"case succ\nn : \u2115\nhn : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n ih", "simp"]
"case succ\nn : \u2115\nih : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Nat.pow_mul]", "rw [Nat.pow_succ, Nat.pow_one]", "induction' n with n IH", "simp"]
"case succ\nn : \u2115\nIH : (2 * 2) ^ n = \u2211 k in range (n + 1), Nat.choose (2 * n) k + \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k\n\u22a2 (2 * 2) ^ succ n =\n    \u2211 k in range (succ n + 1), Nat.choose (2 * succ n) k +\n      \u2211 k in Ico (succ n + 1) (2 * succ n + 1), Nat.choose (2 * succ n) k"

["rw[Finset.sum_range_add_sum_Ico]", "rw [sum_range_choose]"]
"case h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["rw[Finset.sum_range_add_sum_Ico]", "rw[sum_congr rfl]"]
"n : \u2115\n\u22a2 2 ^ (2 * n) = Finset.sum (range (2 * n + 1)) ?m.105142\n\nn : \u2115\n\u22a2 \u2200 x \u2208 range (2 * n + 1), Nat.choose (2 * n) x = ?m.105142 x\n\nn : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase h\nn : \u2115\n\u22a2 n + 1 \u2264 2 * n + 1"

["congr 1"]
"case e_a\nn : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n)"

["rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) * \u2191n = \u2191n * \u2191(Nat.choose (2 * n - 1) n)"

["rw [mul_div]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191n * \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191n * \u2191(Nat.choose (2 * n - 1) n)"

["simp"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["push_cast"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191n * (\u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!)) = \u2191n * \u2191(Nat.choose (2 * n - 1) n)"

["norm_cast"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191n * (\u2191(2 * n - 1)! / \u2191(n ! * (n - 1)!)) = \u2191(n * Nat.choose (2 * n - 1) n)"

["have : 1 \u2264 2 * n := by linarith", "congr 1"]
"case e_a\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n)"

["norm_cast", "rw [cast_mul]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191n * (\u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!)) = \u2191(n * Nat.choose (2 * n - 1) n)"

["simp", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\n\u22a2 n \u2264 2 * n - 1"

["simp", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "cases' n with n"]
"case zero\nh : 1 \u2264 zero\n\u22a2 \u2191(2 * zero - 1)! / (\u2191zero ! * \u2191(zero - 1)!) = \u2191(Nat.choose (2 * zero - 1) zero) \u2228 zero = 0\n\ncase succ\nn : \u2115\nh : 1 \u2264 succ n\n\u22a2 \u2191(2 * succ n - 1)! / (\u2191(succ n)! * \u2191(succ n - 1)!) = \u2191(Nat.choose (2 * succ n - 1) (succ n)) \u2228 succ n = 0"

["simp", "cases n"]
"case zero\nh : 1 \u2264 zero\n\u22a2 \u2191(2 * zero - 1)! / (\u2191zero ! * \u2191(zero - 1)!) = \u2191(Nat.choose (2 * zero - 1) zero) \u2228 zero = 0\n\ncase succ\nn\u271d : \u2115\nh : 1 \u2264 succ n\u271d\n\u22a2 \u2191(2 * succ n\u271d - 1)! / (\u2191(succ n\u271d)! * \u2191(succ n\u271d - 1)!) = \u2191(Nat.choose (2 * succ n\u271d - 1) (succ n\u271d)) \u2228 succ n\u271d = 0"

["simp", "cases n", "exact Or.inr rfl"]
"case succ\nn\u271d : \u2115\nh : 1 \u2264 succ n\u271d\n\u22a2 \u2191(2 * succ n\u271d - 1)! / (\u2191(succ n\u271d)! * \u2191(succ n\u271d - 1)!) = \u2191(Nat.choose (2 * succ n\u271d - 1) (succ n\u271d)) \u2228 succ n\u271d = 0"

["simp", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 n \u2264 2 * n - 1"

["simp", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh this : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh this : 1 \u2264 n\n\u22a2 n \u2264 2 * n - 1"

["norm_cast", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / \u2191(n ! * (n - 1)!) * \u2191n = \u2191(n * Nat.choose (2 * n - 1) n)"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "norm_cast"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / \u2191(n ! * (n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "have : 1 \u2264 2 * n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 2 * n\n\u22a2 n \u2264 2 * n - 1"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 n \u2264 n * 2 - 1"

["simp", "rw [mul_comm]", "cases n"]
"case zero\nh : 1 \u2264 zero\n\u22a2 \u2191(zero * 2 - 1)! / (\u2191zero ! * \u2191(zero - 1)!) = \u2191(Nat.choose (zero * 2 - 1) zero) \u2228 zero = 0\n\ncase succ\nn\u271d : \u2115\nh : 1 \u2264 succ n\u271d\n\u22a2 \u2191(succ n\u271d * 2 - 1)! / (\u2191(succ n\u271d)! * \u2191(succ n\u271d - 1)!) = \u2191(Nat.choose (succ n\u271d * 2 - 1) (succ n\u271d)) \u2228 succ n\u271d = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1"

["simp", "have n_pos : 0 < n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nn_pos : 0 < n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nn_pos : 0 < n\n\u22a2 n \u2264 2 * n - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh this : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh this : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1"

["simp", "cases n", "rw [factorial_zero]"]
"case zero\nh : 1 \u2264 zero\n\u22a2 \u21911 / (\u21911 * \u21911) = \u2191(Nat.choose (2 * zero - 1) zero) \u2228 zero = 0\n\ncase succ\nn\u271d : \u2115\nh : 1 \u2264 succ n\u271d\n\u22a2 \u2191(2 * succ n\u271d - 1)! / (\u2191(succ n\u271d)! * \u2191(succ n\u271d - 1)!) = \u2191(Nat.choose (2 * succ n\u271d - 1) (succ n\u271d)) \u2228 succ n\u271d = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "norm_cast"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / \u2191(n ! * (n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm] at this"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "norm_cast"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / \u2191(n ! * (n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "norm_cast", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / \u2191(n ! * (n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 2 * n - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n := by linarith", "rw [mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (2 * n - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "norm_cast"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / \u2191(n ! * (n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "field_simp"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! = \u2191(Nat.choose (n * 2 - 1) n) * (\u2191n ! * \u2191(n - 1)!) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "norm_num"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191(Nat.choose (n * 2 - 1) n) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 n \u2264 2 * n - 1"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 2 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "have : 1 \u2264 n * 2 := by linarith", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 2 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b2 this\u271d\u00b9 : 1 \u2264 n * 2\nthis\u271d : 2 \u2264 n * 2\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d : 1 \u2264 n * 2\nthis : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "have : 1 \u2264 n * 2 := by linarith", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d\u00b9 this\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [choose_eq_factorial_div_factorial]", "have : 1 \u2264 2 * n := by linarith", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "have : 1 \u2264 n * 2 := by linarith", "norm_cast", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / \u2191(n ! * (n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "have : 1 \u2264 2 * n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 2 * n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 2 * n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [choose_eq_factorial_div_factorial]", "have : 1 \u2264 n * 2 := by linarith", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis\u271d this : 1 \u2264 n * 2\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n * 2 := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 n * 2\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "have : 1 \u2264 2 * n := by linarith", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\nthis : 1 \u2264 2 * n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh this : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh this : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [mul_comm]", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 n \u2264 n * 2 - 1\n\nn : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(n * 2 - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((n * 2 - 1)! / (n ! * (n * 2 - 1 - n)!)) \u2228 n = 0"

["simp", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "have n_pos : 0 < n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh : 1 \u2264 n\nn_pos : 0 < n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh : 1 \u2264 n\nn_pos : 0 < n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["simp", "have : 1 \u2264 n := by linarith", "rw [choose_eq_factorial_div_factorial]", "swap"]
"n : \u2115\nh this : 1 \u2264 n\n\u22a2 n \u2264 2 * n - 1\n\nn : \u2115\nh this : 1 \u2264 n\n\u22a2 \u2191(2 * n - 1)! / (\u2191n ! * \u2191(n - 1)!) = \u2191((2 * n - 1)! / (n ! * (2 * n - 1 - n)!)) \u2228 n = 0"

["rw [pow_mul]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 (2 ^ 2) ^ n"

["rw [pow_mul, pow_two]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ n"

["rw [pow_mul, pow_succ]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 (2 * 2 ^ 1) ^ n"

["apply dvd_pow"]
"case hxy\nn : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 2\n\ncase x\nn : \u2115\nhn : n \u2260 0\n\u22a2 2 * n \u2260 0"

["apply dvd_pow", "norm_num"]
"case x\nn : \u2115\nhn : n \u2260 0\n\u22a2 2 * n \u2260 0"

["rw [pow_mul, pow_two]", "rw [mul_pow]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 2 ^ n * 2 ^ n"

["rw [pow_mul, pow_two]", "induction' n with n ih"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero\n\ncase succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "rw [two_mul]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 (2 + 2) ^ n"

["rw [pow_mul, pow_two]", "induction' n with n hn"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero\n\ncase succ\nn : \u2115\nhn\u271d : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n IH"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero\n\ncase succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases' n with n"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero\n\ncase succ\nn : \u2115\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases n"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero\n\ncase succ\nn\u271d : \u2115\nhn : Nat.succ n\u271d \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\u271d"

["rw [pow_mul, pow_two]", "induction' n with n ih", "contradiction"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n hn", "contradiction"]
"case succ\nn : \u2115\nhn\u271d : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n IH", "contradiction"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases' n with n", "contradiction"]
"case succ\nn : \u2115\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases n", "contradiction"]
"case succ\nn\u271d : \u2115\nhn : Nat.succ n\u271d \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\u271d"

["rw [pow_mul, pow_two]", "induction' n with n IH", "simp [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 False\n\ncase succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases n", "simp [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 False\n\ncase succ\nn\u271d : \u2115\nhn : Nat.succ n\u271d \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\u271d"

["rw [pow_mul, pow_two]", "induction' n with n IH", "rw [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 1\n\ncase succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "simp [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 False\n\ncase succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases' n with n", "simp [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 False\n\ncase succ\nn : \u2115\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "rw [pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 1\n\ncase succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "rw [pow_succ]"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 2 * 2 * (2 * 2) ^ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "rw [pow_succ, mul_assoc]"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 2 * (2 * (2 * 2) ^ n)"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "rw [Nat.succ_eq_add_one] at hn"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : n + 1 \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n IH", "swap"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\n\ncase zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.zero"

["rw [pow_mul, pow_two]", "induction' n with n IH", "cases hn rfl", "rw [pow_succ]"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 2 * 2 * (2 * 2) ^ n"

["rw [pow_mul, pow_two]", "induction' n with n IH", "cases hn rfl", "rw [pow_succ, mul_assoc]"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 2 * (2 * (2 * 2) ^ n)"

["rw [pow_mul, pow_two]", "induction' n with n IH", "cases hn rfl", "rw [Nat.succ_eq_add_one] at hn"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : n + 1 \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n IH", "cases hn rfl", "rw [pow_succ, mul_comm]"]
"case succ\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ n * (2 * 2)"

["rw [pow_mul, pow_two]", "induction' n with n IH", "cases hn rfl", "by_cases hn' : n = 1"]
"case pos\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\nhn' : n = 1\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\n\ncase neg\nn : \u2115\nIH : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\nhn' : \u00acn = 1\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n hn", "simp [Nat.pow_zero]"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 False\n\ncase succ\nn : \u2115\nhn\u271d : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "cases n", "contradiction", "rw [Nat.succ_eq_add_one] at hn"]
"case succ\nn\u271d : \u2115\nhn : n\u271d + 1 \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n\u271d"

["rw [pow_mul, pow_two]", "rw [two_mul]", "rcases Nat.eq_zero_or_pos n with (rfl | hn')"]
"case inl\nhn : 0 \u2260 0\n\u22a2 2 \u2223 (2 + 2) ^ 0\n\ncase inr\nn : \u2115\nhn : n \u2260 0\nhn' : n > 0\n\u22a2 2 \u2223 (2 + 2) ^ n"

["rw [pow_mul, pow_two]", "rw [two_mul]", "rw [add_pow]"]
"n : \u2115\nhn : n \u2260 0\n\u22a2 2 \u2223 Finset.sum (Finset.range (n + 1)) fun m => 2 ^ m * 2 ^ (n - m) * \u2191(Nat.choose n m)"

["rw [pow_mul, pow_two]", "rw [two_mul]", "induction' n with n ih"]
"case zero\nhn : Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 + 2) ^ Nat.zero\n\ncase succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 + 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 + 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "rw [pow_succ, mul_comm]"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : Nat.succ n \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ n * (2 * 2)"

["rw [pow_mul, pow_two]", "cases' n with n", "simp at hn", "rw [Nat.succ_eq_add_one] at hn"]
"case succ\nn : \u2115\nhn : n + 1 \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ n"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "cases n"]
"case succ.zero\nih : Nat.zero \u2260 0 \u2192 2 \u2223 (2 * 2) ^ Nat.zero\nhn : Nat.succ Nat.zero \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ Nat.zero\n\ncase succ.succ\nn\u271d : \u2115\nih : Nat.succ n\u271d \u2260 0 \u2192 2 \u2223 (2 * 2) ^ Nat.succ n\u271d\nhn : Nat.succ (Nat.succ n\u271d) \u2260 0\n\u22a2 2 \u2223 (2 * 2) ^ Nat.succ (Nat.succ n\u271d)"

["rw [pow_mul, pow_two]", "induction' n with n ih", "case zero =>\n  contradiction", "rw [pow_succ]", "rw [Nat.succ_eq_add_one] at hn"]
"case succ\nn : \u2115\nih : n \u2260 0 \u2192 2 \u2223 (2 * 2) ^ n\nhn : n + 1 \u2260 0\n\u22a2 2 \u2223 2 * 2 * (2 * 2) ^ n"

["simp [Nat.pow_succ]"]
"n : \u2115\nh : 2 \u2264 n\n\u22a2 2 ^ (n - 1) = 2 ^ (n - 2) * 2"

["simp [pow_succ]"]
"n : \u2115\nh : 2 \u2264 n\n\u22a2 2 ^ (n - 1) = 2 * 2 ^ (n - 2)"

["congr 1"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\n\u22a2 n - 1 = n - 2 + 1"

["congr 1", "rw [tsub_add_eq_add_tsub h]"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\n\u22a2 n - 1 = n + 1 - 2"

["have : 1 \u2264 n := by linarith", "simp [Nat.pow_succ]"]
"n : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 2 ^ (n - 1) = 2 ^ (n - 2) * 2"

["have : 1 \u2264 n := by linarith", "congr 1"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 n - 1 = n - 2 + 1"

["have : 1 \u2264 n := by linarith", "simp [pow_succ]"]
"n : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 2 ^ (n - 1) = 2 * 2 ^ (n - 2)"

["have : 1 \u2264 n := by linarith", "congr 1", "rw [tsub_add_eq_add_tsub h]"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 n - 1 = n + 1 - 2"

["have : 1 \u2264 n := by linarith", "congr 1", "rw [tsub_add_eq_add_tsub h]", "rw [Nat.sub_eq_iff_eq_add]"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 n = n + 1 - 2 + 1\n\ncase e_a\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 1 \u2264 n"

["have : 1 \u2264 n := by linarith", "congr 1", "rw [tsub_add_eq_add_tsub h]", "rw [Nat.add_sub_assoc]"]
"case e_a\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 n - 1 = n + (1 - 2)\n\ncase e_a.h\nn : \u2115\nh : 2 \u2264 n\nthis : 1 \u2264 n\n\u22a2 2 \u2264 1"

["simp [hnm]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (2 * m + 1) / (2 * m + 2)"

["rw [hnm]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) * (1 / 2) = 2 * (2 * m + 1) / (2 * m + 2) * (1 / 2)"

["nth_rw 1 [hnm]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) * (1 / 2) = 2 * (2 * m + 1) / (n + 2) * (1 / 2)"

["nth_rw 2 [hnm]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) * (1 / 2) = 2 * (n + 1) / (2 * m + 2) * (1 / 2)"

["rw [hnm, two_mul]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (m + m + 1) / (m + 1) * (1 / 2) = 2 * (m + m + 1) / (m + m + 2) * (1 / 2)"

["field_simp [hnm]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / ((m + 1) * 2) = 2 * (2 * m + 1) / ((2 * m + 2) * 2)"

["congr 1"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (n + 1) / (n + 2)"

["subst hnm"]
"m : \u211d\n\u22a2 (2 * m + 1) / (m + 1) * (1 / 2) = 2 * (2 * m + 1) / (2 * m + 2) * (1 / 2)"

["norm_num"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (n + 1) / (n + 2)"

["congr 1", "rw [hnm]"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (2 * m + 1) / (2 * m + 2)"

["congr 1", "conv_rhs =>\n  congr\n  rw [hnm]"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (2 * m + 1) / (n + 2)"

["field_simp [hnm]", "congr 1"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (2 * m + 1)\n\ncase e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (m + 1) * 2 = (2 * m + 2) * 2"

["subst hnm", "congr 1"]
"case e_a\nm : \u211d\n\u22a2 (2 * m + 1) / (m + 1) = 2 * (2 * m + 1) / (2 * m + 2)"

["subst hnm", "nth_rw 1 [\u2190 mul_one (2 * m + 1)]"]
"m : \u211d\n\u22a2 (2 * m + 1) * 1 / (m + 1) * (1 / 2) = 2 * (2 * m + 1) / (2 * m + 2) * (1 / 2)"

["simp [hnm]", "congr 1"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (2 * m + 1)\n\ncase e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = 2 * m + 2"

["congr 1", "rw [hnm, two_mul]"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (m + m + 1) / (m + 1) = 2 * (m + m + 1) / (m + m + 2)"

["field_simp [hnm]", "simp [add_mul, mul_assoc]"]
"n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m * 2 + 2) = 2 * (2 * m + 1) / (2 * (m * 2) + 2 * 2)"

["congr 1", "rw [hnm, mul_comm]"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (m * 2 + 1) / (m + 1) = 2 * (m * 2 + 1) / (m * 2 + 2)"

["congr 1", "rw [hnm, mul_add]"]
"case e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) = (2 * (2 * m) + 2 * 1) / (2 * m + 2)"

["congr 1", "congr 1"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "rw [hnm]", "congr 1"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = 2 * m + 2"

["congr 1", "rw [hnm, mul_comm]", "congr 1"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = 2 * (m * 2 + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = m * 2 + 2"

["congr 1", "rw [hnm, mul_add]", "congr 1"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (2 * m) + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = 2 * m + 2"

["congr 1", "congr 1", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 2 * (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 2 * (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = n + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [mul_comm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = 2 * (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "swap"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (n + 1)"

["congr 1", "congr 1", "rw [hnm]", "simp only [two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = n + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [hnm, mul_add]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 2 * (2 * m) + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [hnm, add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [mul_comm]", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [mul_comm]", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [mul_comm]", "rw [two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = n + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "swap", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = 2 * m + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (n + 1)"

["congr 1", "congr 1", "swap", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = m + m + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 2 * m + 1 = 2 * (n + 1)"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m + 1 = n + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "congr 1"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m = n + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + m + 1 = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "congr"]
"case e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m = n\n\ncase e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m = 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [mul_comm]", "rw [hnm, mul_add]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m * 2 + 1 = 2 * (2 * m) + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [hnm, two_mul]", "simp only [two_mul] at hnm"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m + 1 = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [hnm, two_mul]", "congr 1"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m = m + m + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = m + m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [hnm, add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + (m + 1) + (m + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "conv_rhs =>\n  congr\n  rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m + 1 = m + m + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "ring"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 + m * 2 = 2 + n * 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "congr 1", "rw [hnm]"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m = 2 * m + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "congr 1", "rw [hnm, two_mul]"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m = m + m + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "congr 1", "rw [two_mul] at hnm"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m = n + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + m + 1 = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + 1) + (m + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp only [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = n + (1 + (n + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m + 1 = 0\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = n + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]", "rw [hnm, add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * m + (1 + (2 * m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "rw [hnm, mul_add]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (2 * m) + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "ring", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 + m * 2 = 2 + 2 * m * 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "ring", "rw [hnm, mul_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 + m * 2 = 2 + 2 * (m * 2)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "ring", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 1 + m * 2 = 2 + (m + m) * 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "swap"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (n + 1)"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m = n + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]", "congr"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m = n + 1\n\ncase e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m = n\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [two_mul, add_assoc]", "rw [hnm, two_mul]", "simp only [two_mul] at hnm"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "rw [hnm, mul_add]", "rw [two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * m + 2 * m + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "swap", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = 2 * m + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (n + 1)"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "swap", "rw [hnm, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = m + m + 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = 2 * (n + 1)"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "congr 1"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m = n + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "congr"]
"case e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m = n\n\ncase e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m = 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "ring"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 + m * 2 = 2 + n * 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [hnm, two_mul]", "simp [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + m + 1 = 0\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [hnm, two_mul]", "rw [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = m + (m + 1) + (m + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [hnm, add_assoc]", "rw [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + (m + 1 + (m + (m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [hnm, add_assoc]", "simp only [add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + (m + (1 + (m + (m + 1))))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [hnm, add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m = m + (m + 1)\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + 1 = m + (m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 2 * m + 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + m = 2 * m + 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "congr"]
"case e_a.e_a.e_a.e_a\nm : \u211d\n\u22a2 m = 2 * m\n\ncase e_a.e_a.e_a.e_a\nm : \u211d\n\u22a2 m = 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "ring"]
"case e_a.e_a\nm : \u211d\n\u22a2 1 + m * 2 = 2 + m * 4\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + 1 + (m + (m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "simp only [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (1 + (m + (m + 1))))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m = m + (m + 1)\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 m + 1 = m + (m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (m + 1)) + (m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "congr 1", "rw [two_mul]"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + m = m + m + 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "simp only [two_mul]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + m = m + m + 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = m + m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "congr 1", "rw [two_mul, add_assoc]"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + m = m + (m + 1)\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "rw [two_mul]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + m + 1 + (m + m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "rw [two_mul, add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + m + (1 + (m + m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = 2 * m + (1 + (2 * m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 2 * m = 2 * m + 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 2 * m + (1 + (2 * m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_right_comm]"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 2 * m + (2 * m + 1) + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_comm]"]
"case e_a.e_a\nm : \u211d\n\u22a2 1 + 2 * m = 1 + 2 * m + (1 + 2 * m)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "simp"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 0\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "rw [\u2190 two_mul]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = 2 * (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp only [add_assoc]", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + m + (1 + (m + m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp only [add_assoc]", "rw [hnm, add_add_add_comm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + 1 + (m + (m + m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp only [add_assoc]", "conv_rhs =>\n  congr\n  rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + m + (1 + (n + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "simp only [add_assoc]", "rw [hnm, add_assoc]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + (m + (1 + (m + m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [add_assoc]", "conv_rhs =>\n  congr\n  rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + m + 1 + (n + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "rw [add_assoc]", "rw [hnm, add_add_add_comm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + (m + 1) = m + m + (m + m) + (1 + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "congr 1", "rw [hnm]"]
"case e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m + m = m + m + 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "congr", "rw [hnm]"]
"case e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m = m + m\n\ncase e_a.e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 m = 1\n\ncase e_a.e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 = n + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "rw [two_mul] at hnm", "ring", "rw [hnm]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = m + m\n\u22a2 1 + m * 2 = 2 + (m + m) * 2\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "simp only [add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = 1 + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_right_comm]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 2 * m = 2 * m + (2 * m + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_right_comm]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 2 * m + (2 * m + 1 + 1)\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_right_comm]", "simp only [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 * m + 1 = 2 * m + (2 * m + (1 + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_right_comm]", "rw [two_mul]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + m + 1 = m + m + (m + m + 1) + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "simp"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = 0\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "congr"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m = m + (m + 1)\n\ncase e_a.e_a.e_a.e_a\nm : \u211d\n\u22a2 1 = m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "abel"]
"case e_a.e_a\nm : \u211d\n\u22a2 2 \u2022 m + 1 = 4 \u2022 m + 2 \u2022 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + 1 = m + 1 + (m + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "simp only [add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m + 1 = m + (1 + (m + (m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (m + 1) + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]", "rw [add_assoc, add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (m + 1 + (m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]", "simp only [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (m + (1 + (m + 1))))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m = m + (m + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [two_mul, add_assoc]", "rw [add_right_comm]", "simp [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 1 = m + (1 + (m + 1))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "congr 1"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m = 2 * m + 1\n\ncase e_a.e_a.e_a\nm : \u211d\n\u22a2 m + 1 = 2 * m + 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "congr"]
"case e_a.e_a.e_a\nm : \u211d\n\u22a2 m = 2 * m + 1\n\ncase e_a.e_a.e_a.e_a\nm : \u211d\n\u22a2 m = 2 * m\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [add_assoc]", "rw [two_mul, add_assoc]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 m + (m + 1) = m + (m + (1 + (m + m + 1)))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul, two_mul]", "subst hnm", "rw [\u2190 two_mul]", "rw [add_comm]", "rw [add_assoc]"]
"case e_a.e_a\nm : \u211d\n\u22a2 1 + 2 * m = 1 + (2 * m + (1 + 2 * m))\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["congr 1", "congr 1", "rw [two_mul]", "rw [add_assoc]", "rw [hnm, mul_add]", "rw [two_mul, two_mul]"]
"case e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + (m + 1) = m + m + (m + m) + 2 * 1\n\ncase e_a.e_a\nn m : \u211d\nhnm : n = 2 * m\n\u22a2 m + 1 = n + 2"

["rw [Nat.mul_comm]"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 n * 2 = n * 2 - 1 + 1"

["congr 1"]
"n : \u2115\nh : 1 \u2264 n\n\u22a2 2 * n = 2 * n - 1 + 1"

["rw [div_eq_mul_inv]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k * (2 * m + 1)\u207b\u00b9 = 1 / (2 * m + 1) * \u2191k * (-1) ^ k"

["simp [div_eq_mul_inv]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k * (2 * m + 1)\u207b\u00b9 = (2 * m + 1)\u207b\u00b9 * \u2191k * (-1) ^ k"

["rw [div_eq_mul_one_div]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k * (1 / (2 * m + 1)) = 1 / (2 * m + 1) * \u2191k * (-1) ^ k"

["rw [\u2190 mul_div]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * ((-1) ^ k / (2 * m + 1)) = 1 / (2 * m + 1) * \u2191k * (-1) ^ k"

["rw [mul_assoc]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k / (2 * m + 1) = 1 / (2 * m + 1) * (\u2191k * (-1) ^ k)"

["congr 1"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k / (2 * m + 1) = 1 / (2 * m + 1) * \u2191k * (-1) ^ k"

["rw [one_div]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k / (2 * m + 1) = (2 * m + 1)\u207b\u00b9 * \u2191k * (-1) ^ k"

["simp [div_eq_mul_inv]", "rw [mul_assoc]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * ((-1) ^ k * (2 * m + 1)\u207b\u00b9) = (2 * m + 1)\u207b\u00b9 * \u2191k * (-1) ^ k"

["rw [mul_assoc]", "rw [div_eq_mul_inv]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k * (2 * m + 1)\u207b\u00b9 = 1 / (2 * m + 1) * (\u2191k * (-1) ^ k)"

["simp [div_eq_mul_inv]", "rw [mul_assoc, mul_assoc]"]
"m : \u211d\nk : \u2115\n\u22a2 \u2191k * ((-1) ^ k * (2 * m + 1)\u207b\u00b9) = (2 * m + 1)\u207b\u00b9 * (\u2191k * (-1) ^ k)"

["simp [div_eq_mul_inv]", "congr 1"]
"case e_a\nm : \u211d\nk : \u2115\n\u22a2 \u2191k * (-1) ^ k = (2 * m + 1)\u207b\u00b9 * \u2191k\n\ncase e_a\nm : \u211d\nk : \u2115\n\u22a2 (2 * m + 1)\u207b\u00b9 = (-1) ^ k"

["rw[sum_Ico_eq_sum_range]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1 - 1), (1 + k) * Nat.choose (n - 1) (1 + k - 1) = \u2211 l in Ico 0 n, (l + 1) * Nat.choose (n - 1) l"

["rw[sum_congr rfl]"]
"n : \u2115\n\u22a2 Finset.sum (Ico 1 (n + 1)) ?m.36298 = \u2211 l in Ico 0 n, (l + 1) * Nat.choose (n - 1) l\n\nn : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (n + 1), x * Nat.choose (n - 1) (x - 1) = ?m.36298 x\n\nn : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["simp"]
"n : \u2115\n\u22a2 \u2211 k in Ico 1 (n + 1), k * Nat.choose (n - 1) (k - 1) = \u2211 x in range n, (x + 1) * Nat.choose (n - 1) x"

["cases n"]
"case zero\n\u22a2 \u2211 k in Ico 1 (zero + 1), k * Nat.choose (zero - 1) (k - 1) = \u2211 l in Ico 0 zero, (l + 1) * Nat.choose (zero - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["rw[sum_Ico_eq_sum_range]", "simp"]
"n : \u2115\n\u22a2 \u2211 x in range n, (1 + x) * Nat.choose (n - 1) x = \u2211 x in range n, (x + 1) * Nat.choose (n - 1) x"

["rw[sum_Ico_eq_sum_range]", "rw [sum_Ico_eq_sum_range]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1 - 1), (1 + k) * Nat.choose (n - 1) (1 + k - 1) =\n    \u2211 k in range (n - 0), (0 + k + 1) * Nat.choose (n - 1) (0 + k)"

["cases n", "case zero =>\n  simp"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["simp", "rw [sum_Ico_eq_sum_range]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1 - 1), (1 + k) * Nat.choose (n - 1) (1 + k - 1) = \u2211 x in range n, (x + 1) * Nat.choose (n - 1) x"

["cases n", "congr 1"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose (zero - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (zero - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr"]
"case zero.e_s.e_a.h.e_2\n\u22a2 1 = 0\n\ncase zero.e_s.e_a.h.e_3.e_1\n\u22a2 1 = 0\n\ncase zero.e_s.e_b\n\u22a2 zero + 1 = zero\n\ncase zero.e_f\n\u22a2 (fun k => k * Nat.choose (zero - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (zero - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose 0 (k - 1)) = fun l => (l + 1) * Nat.choose 0 l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), (1 + k) * Nat.choose (succ n\u271d - 1) (1 + k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose (pred zero) (pred k)) = fun l => (l + 1) * Nat.choose (pred zero) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp [mul_comm]"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose 0 (k - 1)) = fun l => Nat.choose 0 l * (l + 1)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp [add_mul]"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose 0 (k - 1)) = fun l => l * Nat.choose 0 l + Nat.choose 0 l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k"]
"case zero.e_f.h\nk : \u2115\n\u22a2 k * Nat.choose (zero - 1) (k - 1) = (k + 1) * Nat.choose (zero - 1) k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext l"]
"case zero.e_f.h\nl : \u2115\n\u22a2 l * Nat.choose (zero - 1) (l - 1) = (l + 1) * Nat.choose (zero - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 x\u271d * Nat.choose (zero - 1) (x\u271d - 1) = (x\u271d + 1) * Nat.choose (zero - 1) x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["simp", "rw [range_eq_Ico]"]
"n : \u2115\n\u22a2 \u2211 k in Ico 1 (n + 1), k * Nat.choose (n - 1) (k - 1) = \u2211 x in Ico 0 n, (x + 1) * Nat.choose (n - 1) x"

["simp", "rw [sum_congr rfl]"]
"n : \u2115\n\u22a2 Finset.sum (Ico 1 (n + 1)) ?m.148691 = \u2211 x in range n, (x + 1) * Nat.choose (n - 1) x\n\nn : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (n + 1), x * Nat.choose (n - 1) (x - 1) = ?m.148691 x\n\nn : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "congr 1", "funext l", "simp"]
"case zero.e_f.h\nl : \u2115\n\u22a2 l * Nat.choose 0 (l - 1) = (l + 1) * Nat.choose 0 l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "simp"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose 0 (pred k)) = fun l => (l + 1) * Nat.choose 0 l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "simp [mul_comm]"]
"case zero.e_f\n\u22a2 (fun k => k * Nat.choose 0 (pred k)) = fun l => Nat.choose 0 l * (l + 1)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "simp [pred]"]
"case zero.e_f\n\u22a2 (fun k =>\n      k *\n        Nat.choose 0\n          (match k with\n          | 0 => 0\n          | succ a => a)) =\n    fun l => (l + 1) * Nat.choose 0 l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "funext k"]
"case zero.e_f.h\nk : \u2115\n\u22a2 k * Nat.choose (pred zero) (pred k) = (k + 1) * Nat.choose (pred zero) k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "funext l"]
"case zero.e_f.h\nl : \u2115\n\u22a2 l * Nat.choose (pred zero) (pred l) = (l + 1) * Nat.choose (pred zero) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "funext"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 x\u271d * Nat.choose (pred zero) (pred x\u271d) = (x\u271d + 1) * Nat.choose (pred zero) x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "simp only [Nat.sub_one]", "funext n"]
"case zero.e_f.h\nn : \u2115\n\u22a2 n * Nat.choose (pred zero) (pred n) = (n + 1) * Nat.choose (pred zero) n\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "simp"]
"case zero.e_f.h\nk : \u2115\n\u22a2 k * Nat.choose 0 (k - 1) = (k + 1) * Nat.choose 0 k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "simp"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 x\u271d * Nat.choose 0 (x\u271d - 1) = (x\u271d + 1) * Nat.choose 0 x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "rw [mul_comm]"]
"case zero.e_f.h\nk : \u2115\n\u22a2 Nat.choose (zero - 1) (k - 1) * k = (k + 1) * Nat.choose (zero - 1) k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "simp [mul_comm]"]
"case zero.e_f.h\nk : \u2115\n\u22a2 k * Nat.choose 0 (k - 1) = Nat.choose 0 k * (k + 1)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "congr 1"]
"case zero.e_f.h.e_a\nk : \u2115\n\u22a2 k = k + 1\n\ncase zero.e_f.h.e_a\nk : \u2115\n\u22a2 Nat.choose (zero - 1) (k - 1) = Nat.choose (zero - 1) k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "congr"]
"case zero.e_f.h.e_a\nk : \u2115\n\u22a2 k = k + 1\n\ncase zero.e_f.h.e_a.e_a\nk : \u2115\n\u22a2 k - 1 = k\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "cases k"]
"case zero.e_f.h.zero\n\u22a2 zero * Nat.choose (zero - 1) (zero - 1) = (zero + 1) * Nat.choose (zero - 1) zero\n\ncase zero.e_f.h.succ\nn\u271d : \u2115\n\u22a2 succ n\u271d * Nat.choose (zero - 1) (succ n\u271d - 1) = (succ n\u271d + 1) * Nat.choose (zero - 1) (succ n\u271d)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "rw [mul_comm]"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 Nat.choose (zero - 1) (x\u271d - 1) * x\u271d = (x\u271d + 1) * Nat.choose (zero - 1) x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "rw [Nat.sub_one]"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 x\u271d * Nat.choose (pred zero) (x\u271d - 1) = (x\u271d + 1) * Nat.choose (pred zero) x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "simp [mul_comm]"]
"case zero.e_f.h\nx\u271d : \u2115\n\u22a2 x\u271d * Nat.choose 0 (x\u271d - 1) = Nat.choose 0 x\u271d * (x\u271d + 1)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "congr 1"]
"case zero.e_f.h.e_a\nx\u271d : \u2115\n\u22a2 x\u271d = x\u271d + 1\n\ncase zero.e_f.h.e_a\nx\u271d : \u2115\n\u22a2 Nat.choose (zero - 1) (x\u271d - 1) = Nat.choose (zero - 1) x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext", "congr"]
"case zero.e_f.h.e_a\nx\u271d : \u2115\n\u22a2 x\u271d = x\u271d + 1\n\ncase zero.e_f.h.e_a.e_a\nx\u271d : \u2115\n\u22a2 x\u271d - 1 = x\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "congr 1", "funext k", "cases k", "simp"]
"case zero.e_f.h.zero\n\u22a2 False\n\ncase zero.e_f.h.succ\nn\u271d : \u2115\n\u22a2 succ n\u271d * Nat.choose (zero - 1) (succ n\u271d - 1) = (succ n\u271d + 1) * Nat.choose (zero - 1) (succ n\u271d)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 1 (succ n\u271d + 1), k * Nat.choose (succ n\u271d - 1) (k - 1) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "simp"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 x in Ico 1 (succ n\u271d + 1), x * Nat.choose n\u271d (x - 1) = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x"

["cases n", "case zero =>\n  simp", "congr 1"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (succ n\u271d + 1) = Ico 0 (succ n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr"]
"case succ.e_s.e_a.h.e_2\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_a.h.e_3.e_1\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_b\nn\u271d : \u2115\n\u22a2 succ n\u271d + 1 = succ n\u271d\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "simp only [Nat.succ_eq_add_one]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (n\u271d + 1 + 1) = Ico 0 (n\u271d + 1)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "rw [Nat.succ_eq_one_add]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (1 + n\u271d + 1) = Ico 0 (1 + n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "rw [Nat.Ico_succ_right]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Icc 1 (n\u271d + 1) = Ico 0 (succ n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "congr 1"]
"case succ.e_s.e_a\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_b\nn\u271d : \u2115\n\u22a2 succ n\u271d + 1 = succ n\u271d\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "simp [Ico]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 LocallyFiniteOrder.finsetIco 1 (succ n\u271d + 1) = LocallyFiniteOrder.finsetIco 0 (succ n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "simp"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (succ n\u271d + 1) = range (succ n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "rw [sum_Ico_eq_sum_range]", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), (1 + k) * Nat.choose (succ n\u271d - 1) (1 + k - 1) =\n    \u2211 k in range (succ n\u271d - 0), (0 + k + 1) * Nat.choose (succ n\u271d - 1) (0 + k)"

["cases n", "case zero =>\n  simp", "rw [sum_Ico_eq_sum_range]", "simp"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 x in range (succ n\u271d), (1 + x) * Nat.choose n\u271d x = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), ?succ.f (1 + k) = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?succ.f x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [Finset.sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.271151 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.271150 x = ?m.271151 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.271150 x"

["cases n", "case zero =>\n  simp", "simp", "rw [range_eq_Ico]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 x in Ico 1 (succ n\u271d + 1), x * Nat.choose n\u271d (x - 1) = \u2211 x in Ico 0 (succ n\u271d), (x + 1) * Nat.choose n\u271d x"

["cases n", "case zero =>\n  simp", "rw [sum_Ico_eq_sum_range]", "rw [sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (range (succ n\u271d + 1 - 1)) ?m.273244 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 range (succ n\u271d + 1 - 1), (1 + x) * Nat.choose (succ n\u271d - 1) (1 + x - 1) = ?m.273244 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "congr 1", "rw [Nat.succ_eq_one_add]", "congr 1"]
"case succ.e_s.e_a\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_b\nn\u271d : \u2115\n\u22a2 1 + n\u271d + 1 = 1 + n\u271d\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "congr 1", "rw [Nat.succ_eq_one_add]", "simp only [add_assoc]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (1 + (n\u271d + 1)) = Ico 0 (1 + n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "simp", "rw [sum_range_succ]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 x in Ico 1 (succ n\u271d + 1), x * Nat.choose n\u271d (x - 1) =\n    \u2211 x in range n\u271d, (x + 1) * Nat.choose n\u271d x + (n\u271d + 1) * Nat.choose n\u271d n\u271d"

["cases n", "case zero =>\n  simp", "congr 1", "rw [Nat.succ_eq_one_add]", "simp [add_assoc]"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (1 + (n\u271d + 1)) = range (1 + n\u271d)\n\ncase succ.e_f\nn\u271d : \u2115\n\u22a2 (fun k => k * Nat.choose (succ n\u271d - 1) (k - 1)) = fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.278345 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.278344 x = ?m.278345 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.278344 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [Finset.sum]"]
"case succ\nn\u271d : \u2115\n\u22a2 Multiset.sum (Multiset.map ?succ.f (Ico 1 (succ n\u271d + 1)).val) =\n    \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?succ.f x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "simp"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "congr 1"]
"case succ.e_s\nn\u271d : \u2115\n\u22a2 Ico 1 (succ n\u271d + 1) = Ico 0 (succ n\u271d)\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = (x + 1) * Nat.choose (succ n\u271d - 1) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "congr"]
"case succ.e_s.e_a.h.e_2\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_a.h.e_3.e_1\nn\u271d : \u2115\n\u22a2 1 = 0\n\ncase succ.e_s.e_b\nn\u271d : \u2115\n\u22a2 succ n\u271d + 1 = succ n\u271d\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = (x + 1) * Nat.choose (succ n\u271d - 1) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "swap"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\ncase succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_Ico_eq_sum_range]", "simp"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 x in range (succ n\u271d), ?succ.f (1 + x) = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?succ.f x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_congr rfl]", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), ?succ.f (1 + k) = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.278344 x = ?succ.f x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.278344 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (n\u271d + 1 + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b hb ih"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nih :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b hb hbc"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nhbc :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b _ hb"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (succ n\u271d + 1)\nhb :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b hb h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro x hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 x \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b _ h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro l hl"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : l \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : b \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 (b : \u2115),\n    1 \u2264 b \u2192\n      b < succ n\u271d + 1 \u2192\n        \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192\n          False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro a ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 a \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro l h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : l \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "simp", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), ?succ.f (1 + k) = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?succ.f x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "simp", "rw [Finset.sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.301035 = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.301034 x = ?m.301035 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.301034 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "swap", "intro x hx"]
"case succ\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\ncase succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    \u00acb =\n          List.foldr (fun x x_1 => x + x_1) 0\n            (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro x hx", "rw [mem_Ico] at hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : 1 \u2264 x \u2227 x < succ n\u271d + 1\n\u22a2 x \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_Ico_eq_sum_range]", "rw [Finset.range_eq_Ico]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in Ico 0 (succ n\u271d + 1 - 1), ?succ.f (1 + k) = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?succ.f x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [sum_congr rfl]", "rw [Finset.sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.303308 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.303307 x = ?m.303308 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.278344 x = ?m.303307 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.278344 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "swap", "simp only [mem_Ico]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2200 (x : \u2115), 1 \u2264 x \u2227 x < succ n\u271d + 1 \u2192 x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\ncase succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro l hl", "rw [mem_Ico] at hl"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : 1 \u2264 l \u2227 l < succ n\u271d + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b \u2227 b < succ n\u271d + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h\u2081 h\u2082"]
"case succ.h\u2080\nn\u271d b : \u2115\nh\u2081 : 1 \u2264 b\nh\u2082 : b < succ n\u271d + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "rw [succ_eq_add_one] at *"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 (b : \u2115),\n    1 \u2264 b \u2192\n      b < n\u271d + 1 + 1 \u2192\n        \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192\n          False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro l h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : 1 \u2264 l \u2227 l < succ n\u271d + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "rw [succ_eq_add_one]"]
"case succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (n\u271d + 1 + 1),\n    \u00acb =\n          List.foldr (fun x x_1 => x + x_1) 0\n            (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      (0 + 1) * Nat.choose (n\u271d + 1 - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b hb ih"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nih :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00acb =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b _ hb"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (succ n\u271d + 1)\nhb :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b hb h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx h"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b _ h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : b \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00acb =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "rw [succ_eq_add_one]"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (n\u271d + 1 + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "rw [Nat.add_zero]"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' 1 n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' 1 n\u271d))) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro a ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00aca =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro i _"]
"case succ.h\u2080\nn\u271d i : \u2115\na\u271d : i \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00aci =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + i = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro l h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : l \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00acl =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x h"]
"case succ.h\u2080\nn\u271d x : \u2115\nh : x \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "swap"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    \u00acb =\n          List.foldr (fun x x_1 => x + x_1) 0\n            (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b hb", "rw [succ_eq_add_one] at hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00acb =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b hb h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx", "rw [succ_eq_add_one] at hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx", "rw [mem_Ico] at hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : 1 \u2264 x \u2227 x < succ n\u271d + 1\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx h", "rw [mem_Ico] at hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : 1 \u2264 x \u2227 x < succ n\u271d + 1\nh :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b _ h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : b \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00acb =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b \u2227 b < succ n\u271d + 1\n\u22a2 \u00acb =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro a ha", "rw [Nat.succ_eq_add_one] at ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00aca =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro a ha", "rw [Nat.succ_eq_one_add] at ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (1 + n\u271d + 1)\n\u22a2 \u00aca =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro a ha", "rw [mem_Ico] at ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : 1 \u2264 a \u2227 a < succ n\u271d + 1\n\u22a2 \u00aca =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro a ha", "intro h"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00aca =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro i _", "rw [succ_eq_add_one]"]
"case succ.h\u2080\nn\u271d i : \u2115\na\u271d : i \u2208 Ico 1 (succ n\u271d + 1)\n\u22a2 \u00aci =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (n\u271d + 1 - 1) 0 + i = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro i _", "intro h"]
"case succ.h\u2080\nn\u271d i : \u2115\na\u271d : i \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00aci =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + i = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro l h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : l \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00acl =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro l h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : l \u2208 Ico 1 (succ n\u271d + 1)\nh\u2081 :\n  \u00acl =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d x : \u2115\nh : x \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d x : \u2115\nh : 1 \u2264 x \u2227 x < succ n\u271d + 1\n\u22a2 \u00acx =\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx h", "rw [Nat.add_zero]"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 1 * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro b h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : b \u2208 Ico 1 (succ n\u271d + 1)\nh\u2081 :\n  \u00acb =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d x : \u2115\nh : x \u2208 Ico 1 (succ n\u271d + 1)\nh\u2081 :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 (0 + 1) * Nat.choose (succ n\u271d - 1) 0 + x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h"]
"case succ.h\u2081\nn\u271d : \u2115\nh :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h\u2081"]
"case succ.h\u2081\nn\u271d : \u2115\nh\u2081 :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h\u2082"]
"case succ.h\u2081\nn\u271d : \u2115\nh\u2082 :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "simp_all"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 (1 \u2264 List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192\n      succ n\u271d + 1 \u2264\n        List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))) \u2192\n    False\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "dsimp only"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((0 + 1) * Nat.choose (succ n\u271d - 1) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h1"]
"case succ.h\u2081\nn\u271d : \u2115\nh1 :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "dsimp"]
"case succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    (0 + 1) * Nat.choose (succ n\u271d - 1) 0 +\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) =\n      0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h", "rw [Nat.add_zero]"]
"case succ.h\u2081\nn\u271d : \u2115\nh :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' 1 n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h\u2081", "rw [Nat.add_zero]"]
"case succ.h\u2081\nn\u271d : \u2115\nh\u2081 :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' 1 n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "swap", "intro h\u2082", "rw [Nat.add_zero]"]
"case succ.h\u2081\nn\u271d : \u2115\nh\u2082 :\n  List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n    Ico 1 (succ n\u271d + 1)\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n      (List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' 1 n\u271d))) =\n    0\n\ncase succ.h\u2080\nn\u271d : \u2115\n\u22a2 \u2200 b \u2208 Ico 1 (succ n\u271d + 1),\n    b \u2260\n        List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n      Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "dsimp", "intro x hx h", "simp"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (succ n\u271d + 1)\nh :\n  \u00acx =\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "rw [Finset.sum_congr rfl]", "rw [sum_Ico_eq_sum_range]"]
"case succ\nn\u271d : \u2115\n\u22a2 \u2211 k in range (succ n\u271d + 1 - 1), ?succ.f (1 + k) = \u2211 l in Ico 0 (succ n\u271d), (l + 1) * Nat.choose (succ n\u271d - 1) l\n\ncase succ.f\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.271150 x = ?succ.f x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.271150 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "simp", "rw [sum_range_succ]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.253243 = \u2211 x in range n\u271d, (x + 1) * Nat.choose n\u271d x + (n\u271d + 1) * Nat.choose n\u271d n\u271d\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.253243 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "simp", "rw [sum_congr rfl]"]
"case succ\nn\u271d : \u2115\n\u22a2 Finset.sum (Ico 1 (succ n\u271d + 1)) ?m.330314 = \u2211 x in range (succ n\u271d), (x + 1) * Nat.choose n\u271d x\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), ?m.330313 x = ?m.330314 x\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\nn\u271d : \u2115\n\u22a2 \u2115 \u2192 \u2115\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1), x * Nat.choose (succ n\u271d - 1) (x - 1) = ?m.330313 x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b hb ih"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (n\u271d + 1 + 1)\nih :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b _ hb"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (n\u271d + 1 + 1)\nhb :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b hb h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : b \u2208 Ico 1 (n\u271d + 1 + 1)\nh :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l hl h"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : l \u2208 Ico 1 (n\u271d + 1 + 1)\nh :\n  l \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro x hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 x \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l hl"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : l \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : b \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b _ h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (n\u271d + 1 + 1)\nh :\n  b \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : l \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro a ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : a \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 a \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b _"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : b \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b hb", "rw [mem_Ico] at hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b \u2227 b < n\u271d + 1 + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b hb", "rw [mem_Ico, lt_succ_iff] at hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b \u2227 b \u2264 n\u271d + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro x hx", "rw [mem_Ico] at hx"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : 1 \u2264 x \u2227 x < n\u271d + 1 + 1\n\u22a2 x \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l hl", "rw [mem_Ico] at hl"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : 1 \u2264 l \u2227 l < n\u271d + 1 + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l hl", "rw [mem_Ico, lt_succ_iff] at hl"]
"case succ.h\u2080\nn\u271d l : \u2115\nhl : 1 \u2264 l \u2227 l \u2264 n\u271d + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b \u2227 b < n\u271d + 1 + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro b h", "rw [mem_Ico, lt_succ_iff] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b \u2227 b \u2264 n\u271d + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l h", "rw [mem_Ico] at h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : 1 \u2264 l \u2227 l < n\u271d + 1 + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro l h", "rw [mem_Ico, lt_succ_iff] at h"]
"case succ.h\u2080\nn\u271d l : \u2115\nh : 1 \u2264 l \u2227 l \u2264 n\u271d + 1\n\u22a2 l \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) l = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro a ha", "rw [mem_Ico] at ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : 1 \u2264 a \u2227 a < n\u271d + 1 + 1\n\u22a2 a \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro a ha", "rw [mem_Ico, lt_succ_iff] at ha"]
"case succ.h\u2080\nn\u271d a : \u2115\nha : 1 \u2264 a \u2227 a \u2264 n\u271d + 1\n\u22a2 a \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) a = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro x hx", "intro h"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (n\u271d + 1 + 1)\nh :\n  x \u2260\n    List.foldr (fun x x_1 => x + x_1) 0\n      (List.map (fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) (List.range' (0 + 1) n\u271d))\n\u22a2 Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "rw [succ_eq_add_one]", "intro x hx", "rw [List.foldr_map]"]
"case succ.h\u2080\nn\u271d x : \u2115\nhx : x \u2208 Ico 1 (n\u271d + 1 + 1)\n\u22a2 x \u2260 List.foldr (fun x y => (x + 1) * Nat.choose (n\u271d + 1 - 1) x + y) 0 (List.range' (0 + 1) n\u271d) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (n\u271d + 1 - 1) l) 0) x = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "intro b hb", "rw [mem_Ico] at hb"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b \u2227 b < succ n\u271d + 1\n\u22a2 b \u2260\n      List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) b = 0\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h\u2081 h\u2082 h\u2083"]
"case succ.h\u2080\nn\u271d b : \u2115\nh\u2081 : 1 \u2264 b\nh\u2082 : b < succ n\u271d + 1\nh\u2083 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h\u2081 h\u2082 h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh\u2081 : 1 \u2264 b\nh\u2082 : b < succ n\u271d + 1\nh : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b hb h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b\nh : b < succ n\u271d + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _ h"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\nh : b\u271d < succ n\u271d + 1\n\u22a2 \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b _ h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : 1 \u2264 b\nh : b < succ n\u271d + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\n\u22a2 b < succ n\u271d + 1 \u2192\n    \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\n\u22a2 b\u271d < succ n\u271d + 1 \u2192\n    \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b"]
"case succ.h\u2080\nn\u271d b : \u2115\n\u22a2 1 \u2264 b \u2192\n    b < succ n\u271d + 1 \u2192\n      \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192\n        False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h\u2081 h\u2082", "rw [succ_eq_add_one] at h\u2082"]
"case succ.h\u2080\nn\u271d b : \u2115\nh\u2081 : 1 \u2264 b\nh\u2082 : b < n\u271d + 1 + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b hb h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b\nh : b < n\u271d + 1 + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b hb h", "intro h"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b\nh\u271d : b < succ n\u271d + 1\nh : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b hb h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d b : \u2115\nhb : 1 \u2264 b\nh : b < succ n\u271d + 1\nh\u2081 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _ h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\nh : b\u271d < n\u271d + 1 + 1\n\u22a2 \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _ h", "rw [lt_succ_iff] at h"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\nh : b\u271d \u2264 n\u271d + 1\n\u22a2 \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _ h", "intro h"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\nh\u271d : b\u271d < succ n\u271d + 1\nh : \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b _ h", "rw [succ_eq_add_one] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : 1 \u2264 b\nh : b < n\u271d + 1 + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b _ h", "rw [lt_succ_iff] at h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : 1 \u2264 b\nh : b \u2264 n\u271d + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "intro h\u2081 h\u2082"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\nh\u2081 : b < succ n\u271d + 1\nh\u2082 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "rw [lt_succ_iff]"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\n\u22a2 b \u2264 n\u271d + 1 \u2192\n    \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b _ h", "intro h"]
"case succ.h\u2080\nn\u271d b : \u2115\na\u271d : 1 \u2264 b\nh\u271d : b < succ n\u271d + 1\nh : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro _ _ h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d b\u271d : \u2115\na\u271d : 1 \u2264 b\u271d\nh : b\u271d < succ n\u271d + 1\nh\u2081 : \u00acb\u271d = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "intro h\u2082 h\u2083"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\nh\u2082 : b < succ n\u271d + 1\nh\u2083 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "intro h\u2080 h\u2081"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\nh\u2080 : b < succ n\u271d + 1\nh\u2081 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "intro h\u2081"]
"case succ.h\u2080\nn\u271d b : \u2115\nh : 1 \u2264 b\nh\u2081 : b < succ n\u271d + 1\n\u22a2 \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d)) \u2192 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["cases n", "case zero =>\n  simp", "rw [sum_congr rfl]", "apply Finset.sum_eq_single", "try simp", "intro b h", "intro h h\u2081"]
"case succ.h\u2080\nn\u271d b : \u2115\nh\u271d : 1 \u2264 b\nh : b < succ n\u271d + 1\nh\u2081 : \u00acb = List.foldr (fun x x_1 => x + x_1) 0 (List.map (fun l => (l + 1) * Nat.choose n\u271d l) (List.range' 1 n\u271d))\n\u22a2 False\n\ncase succ.h\u2081\nn\u271d : \u2115\n\u22a2 List.foldr (fun x x_1 => x + x_1) 0\n        (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d)) \u2209\n      Ico 1 (succ n\u271d + 1) \u2192\n    Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0)\n        (List.foldr (fun x x_1 => x + x_1) 0\n          (List.map (fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) (List.range' (0 + 1) n\u271d))) =\n      0\n\ncase succ\nn\u271d : \u2115\n\u22a2 \u2200 x \u2208 Ico 1 (succ n\u271d + 1),\n    x * Nat.choose (succ n\u271d - 1) (x - 1) = Nat.add ((fun l => (l + 1) * Nat.choose (succ n\u271d - 1) l) 0) x"

["rw [mul_sum]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1), -1 * (\u2191n - \u2191k - \u2191n) * \u2191(Nat.choose (2 * n) (n - k)) =\n    \u2211 x in range (n + 1), -1 * ((\u2191n - \u2191x - \u2191n) * \u2191(Nat.choose (2 * n) (n - x)))"

["rw [Nat.sub_add_cancel]"]
"n : \u2115\n\u22a2 2 ^ n = 2 * 2 ^ (n - 1)\n\nn : \u2115\n\u22a2 1 \u2264 n"

["rw[Nat.pow_succ]"]
"n : \u2115\n\u22a2 2 ^ (n - 1) * 2 = 2 * 2 ^ (n - 1)"

["congr 1"]
"n : \u2115\n\u22a2 2 ^ (n - 1 + 1) = 2 * 2 ^ (n - 1)"

["simp"]
"n : \u2115\nh : 0 < n\n\u22a2 2 * n - 1 + 1 = 2 * n"

["rw [Nat.add_sub_assoc]"]
"n : \u2115\nh : 0 < n\n\u22a2 2 * n - 1 + (1 - 0) = 2 * n\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["simp [two_mul]"]
"n : \u2115\nh : 0 < n\n\u22a2 n + n - 1 + 1 = n + n"

["congr 1"]
"n : \u2115\nh : 0 < n\n\u22a2 2 * n - 1 + 1 - 0 = 2 * n"

["rw [Nat.add_sub_assoc]", "simp"]
"n : \u2115\nh : 0 < n\n\u22a2 2 * n - 1 + 1 = 2 * n\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["simp [two_mul]", "rw [Nat.add_sub_assoc h]"]
"n : \u2115\nh : 0 < n\n\u22a2 n + (n - succ 0) + 1 = n + n"

["simp [two_mul]", "rw [Nat.add_sub_assoc]"]
"n : \u2115\nh : 0 < n\n\u22a2 n + (n - 1) + 1 = n + n\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 1 \u2264 n"

["rw [Nat.add_sub_assoc]", "cases n"]
"case zero\nh : 0 < zero\n\u22a2 2 * zero - 1 + (1 - 0) = 2 * zero\n\ncase succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "swap"]
"case h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1\n\nn : \u2115\nh : 0 < n\n\u22a2 2 * n - 1 + (1 - 0) = 2 * n"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim"]
"case succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "rw [Nat.zero_eq] at h"]
"case zero\nh : 0 < 0\n\u22a2 2 * zero - 1 + (1 - 0) = 2 * zero\n\ncase succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "rw [Nat.sub_zero]"]
"case zero\nh : 0 < zero\n\u22a2 2 * zero - 1 + 1 = 2 * zero\n\ncase succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "norm_num"]
"case zero\nh : 0 < zero\n\u22a2 False\n\ncase succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [Nat.sub_zero]"]
"case succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + 1 = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [Nat.succ_eq_add_one] at h"]
"case succ\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "simp [succ_eq_add_one]"]
"case succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * (n\u271d + 1) - 1 + 1 = 2 * (n\u271d + 1)\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [succ_eq_add_one]"]
"case succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * (n\u271d + 1) - 1 + (1 - 0) = 2 * (n\u271d + 1)\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "congr 1"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rfl"]
"case h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [Nat.sub_zero]", "rw [Nat.succ_eq_add_one] at h"]
"case succ\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * succ n\u271d - 1 + 1 = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "simp [succ_eq_add_one]", "rw [Nat.succ_eq_add_one] at h"]
"case succ\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * (n\u271d + 1) - 1 + 1 = 2 * (n\u271d + 1)\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "congr 1", "rw [Nat.succ_eq_add_one] at h"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * succ n\u271d - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "congr 1", "rw [Nat.mul_comm]"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 succ n\u271d * 2 - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "congr 1", "rw [Nat.succ_mul]"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 * succ n\u271d + succ n\u271d - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "congr 1", "rw [Nat.mul_succ]"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * n\u271d + 2 - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [Nat.succ_eq_add_one] at h", "rw [succ_eq_add_one]"]
"case succ\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * (n\u271d + 1) - 1 + (1 - 0) = 2 * (n\u271d + 1)\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [Nat.succ_eq_add_one] at h", "congr 1"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * succ n\u271d - 1 = Nat.mul 2 n\u271d\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [succ_eq_add_one]", "congr 1"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * (n\u271d + 1) - 1 = Nat.mul 2 (Nat.add n\u271d 0)\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "exact (lt_irrefl _ h).elim", "rw [succ_eq_add_one]", "congr 1", "rw [Nat.succ_eq_add_one] at h"]
"case succ.e_a\nn\u271d : \u2115\nh : 0 < n\u271d + 1\n\u22a2 2 * (n\u271d + 1) - 1 = Nat.mul 2 (Nat.add n\u271d 0)\n\ncase succ.e_a\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 1 - 0 = 2\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw [Nat.add_sub_assoc]", "cases n", "rw [Nat.zero_eq] at h", "rw [Nat.sub_zero]"]
"case zero\nh : 0 < 0\n\u22a2 2 * zero - 1 + 1 = 2 * zero\n\ncase succ\nn\u271d : \u2115\nh : 0 < succ n\u271d\n\u22a2 2 * succ n\u271d - 1 + (1 - 0) = 2 * succ n\u271d\n\ncase h\nn : \u2115\nh : 0 < n\n\u22a2 0 \u2264 1"

["rw[\u2190 range_sub_choose]"]
"n : \u2115\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range (n + 1), Nat.choose (2 * n) k = 2 ^ (2 * n)"

["rw[sum_range_add]"]
"n : \u2115\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n      (\u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x)) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "rw[Ico_choose_range_choose]"]
"n : \u2115\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range (n + 1), Nat.choose (2 * n) k =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "rw[range_eq_Ico]"]
"n : \u2115\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 (n + 1), Nat.choose (2 * n) k = 2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "rw[sum_range_add]"]
"n : \u2115\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k +\n      (\u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x)) =\n    2 ^ (2 * n)"

["rw[sum_range_add]", "rw[\u2190 add_assoc]"]
"n : \u2115\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n        \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range (n + 1), Nat.choose (2 * n) k =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 (n + 1), Nat.choose (2 * n) k = 2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "rw[sum_range_add]"]
"n : \u2115\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k +\n      (\u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x)) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range (n + 1), Nat.choose (2 * n) k =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 (n + 1), Nat.choose (2 * n) k = 2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k +\n      (\u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x)) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range (n + 1), Nat.choose (2 * n) k =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 (n + 1), Nat.choose (2 * n) k = 2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k +\n      (\u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x)) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "rw[\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "rw [\u2190 add_assoc]", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "rw [\u2190 add_assoc]", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < 2 * n + 1 := by linarith", "simp"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "simp"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "rw [sum_range_add]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "simp"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 x in range n, Nat.choose (2 * n) x +\n      \u2211 x in range 1, Nat.choose (2 * n) (n + x) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "rw[Ico_choose_range_choose]", "rw [sum_range_add]"]
"n : \u2115\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d this : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d this : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d this : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[Ico_choose_range_choose]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u2074 : 0 < n + 1\nthis\u271d\u00b3 this\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 this\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u2074 : 0 < n + 1\nthis\u271d\u00b3 this\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 this\u271d : 0 < n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[range_eq_Ico]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in Ico 0 n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u2074 : 0 < n + 1\nthis\u271d\u00b3 this\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d : 0 < 2 * n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u2074 : 0 < n + 1\nthis\u271d\u00b3 this\u271d\u00b2 : 0 < 2 * n + 1\nthis\u271d\u00b9 : 0 < n + 1\nthis\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "rw [sum_range_add]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n      (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 0 < 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "have : 1 \u2264 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b3 : 0 < n + 1\nthis\u271d\u00b2 this\u271d\u00b9 : 0 < 2 * n + 1\nthis\u271d : 0 < n + 1\nthis : 1 \u2264 2 * n + 1\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n + \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "have : 0 < n + 1 := by linarith", "rw[Ico_choose_range_choose]", "rw [sum_range_add]", "rw [\u2190 add_assoc]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d : 0 < 2 * n + 1\nthis : 0 < n + 1\n\u22a2 \u2211 x in range n, Nat.choose (2 * n) x + \u2211 x in range 1, Nat.choose (2 * n) (n + x) - Nat.choose (2 * n) n +\n        \u2211 k in range n, Nat.choose (2 * n) k +\n      Nat.choose (2 * n) n =\n    2 ^ (2 * n)"

["rw[\u2190 range_sub_choose]", "have : 0 < n + 1 := by linarith", "have : 0 < 2 * n + 1 := by linarith", "rw[sum_range_add]", "simp", "have : 0 < 2 * n + 1 := by linarith", "rw [\u2190 add_assoc]", "rw[add_assoc]", "have : 0 < 2 * n + 1 := by linarith", "rw[Ico_choose_eq_Ico_choose_add]"]
"n : \u2115\nthis\u271d\u00b2 : 0 < n + 1\nthis\u271d\u00b9 this\u271d this : 0 < 2 * n + 1\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k + (\u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n) =\n    2 ^ (2 * n)"

